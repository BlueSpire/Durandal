<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\plugins\js\router.js - Durandal API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Durandal API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.2.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Activator.html">Activator</a></li>
                                <li><a href="../classes/ActivatorModule.html">ActivatorModule</a></li>
                                <li><a href="../classes/ActivatorSettings.html">ActivatorSettings</a></li>
                                <li><a href="../classes/AppModule.html">AppModule</a></li>
                                <li><a href="../classes/BinderModule.html">BinderModule</a></li>
                                <li><a href="../classes/CompositionModule.html">CompositionModule</a></li>
                                <li><a href="../classes/CompositionTransaction.html">CompositionTransaction</a></li>
                                <li><a href="../classes/DialogContext.html">DialogContext</a></li>
                                <li><a href="../classes/DialogModule.html">DialogModule</a></li>
                                <li><a href="../classes/EntranceModule.html">EntranceModule</a></li>
                                <li><a href="../classes/Events.html">Events</a></li>
                                <li><a href="../classes/EventsModule.html">EventsModule</a></li>
                                <li><a href="../classes/HistoryModule.html">HistoryModule</a></li>
                                <li><a href="../classes/HistoryOptions.html">HistoryOptions</a></li>
                                <li><a href="../classes/HTTPModule.html">HTTPModule</a></li>
                                <li><a href="../classes/MessageBox.html">MessageBox</a></li>
                                <li><a href="../classes/ObservableModule.html">ObservableModule</a></li>
                                <li><a href="../classes/Router.html">Router</a></li>
                                <li><a href="../classes/RouterModule.html">RouterModule</a></li>
                                <li><a href="../classes/SerializerModule.html">SerializerModule</a></li>
                                <li><a href="../classes/Subscription.html">Subscription</a></li>
                                <li><a href="../classes/SystemModule.html">SystemModule</a></li>
                                <li><a href="../classes/ViewEngineModule.html">ViewEngineModule</a></li>
                                <li><a href="../classes/ViewLocatorModule.html">ViewLocatorModule</a></li>
                                <li><a href="../classes/WidgetModule.html">WidgetModule</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/activator.html">activator</a></li>
                                <li><a href="../modules/app.html">app</a></li>
                                <li><a href="../modules/binder.html">binder</a></li>
                                <li><a href="../modules/composition.html">composition</a></li>
                                <li><a href="../modules/dialog.html">dialog</a></li>
                                <li><a href="../modules/entrance.html">entrance</a></li>
                                <li><a href="../modules/events.html">events</a></li>
                                <li><a href="../modules/history.html">history</a></li>
                                <li><a href="../modules/http.html">http</a></li>
                                <li><a href="../modules/observable.html">observable</a></li>
                                <li><a href="../modules/router.html">router</a></li>
                                <li><a href="../modules/serializer.html">serializer</a></li>
                                <li><a href="../modules/system.html">system</a></li>
                                <li><a href="../modules/viewEngine.html">viewEngine</a></li>
                                <li><a href="../modules/viewLocator.html">viewLocator</a></li>
                                <li><a href="../modules/widget.html">widget</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\plugins\js\router.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿/**
 * Connects the history module&#x27;s url and history tracking support to Durandal&#x27;s activation and composition engine allowing you to easily build navigation-style applications.
 * @module router
 * @requires system
 * @requires app
 * @requires activator
 * @requires events
 * @requires composition
 * @requires history
 * @requires knockout
 * @requires jquery
 */
define([&#x27;durandal/system&#x27;, &#x27;durandal/app&#x27;, &#x27;durandal/activator&#x27;, &#x27;durandal/events&#x27;, &#x27;durandal/composition&#x27;, &#x27;plugins/history&#x27;, &#x27;knockout&#x27;, &#x27;jquery&#x27;], function(system, app, activator, events, composition, history, ko, $) {
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    var startDeferred, rootRouter;
    var trailingSlash = /\/$/;
    var routesAreCaseSensitive = false;
    var lastUrl = &#x27;/&#x27;, lastTryUrl = &#x27;/&#x27;;

    function routeStringToRegExp(routeString) {
        routeString = routeString.replace(escapeRegExp, &#x27;\\$&amp;&#x27;)
            .replace(optionalParam, &#x27;(?:$1)?&#x27;)
            .replace(namedParam, function(match, optional) {
                return optional ? match : &#x27;([^\/]+)&#x27;;
            })
            .replace(splatParam, &#x27;(.*?)&#x27;);

        return new RegExp(&#x27;^&#x27; + routeString + &#x27;$&#x27;, routesAreCaseSensitive ? undefined : &#x27;i&#x27;);
    }

    function stripParametersFromRoute(route) {
        var colonIndex = route.indexOf(&#x27;:&#x27;);
        var length = colonIndex &gt; 0 ? colonIndex - 1 : route.length;
        return route.substring(0, length);
    }

    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    function compareArrays(first, second) {
        if (!first || !second){
            return false;
        }

        if (first.length != second.length) {
            return false;
        }

        for (var i = 0, len = first.length; i &lt; len; i++) {
            if (first[i] != second[i]) {
                return false;
            }
        }

        return true;
    }

    function reconstructUrl(instruction){
        if(!instruction.queryString){
            return instruction.fragment;
        }

        return instruction.fragment + &#x27;?&#x27; + instruction.queryString;
    }

    /**
     * @class Router
     * @uses Events
     */

    /**
     * Triggered when the navigation logic has completed.
     * @event router:navigation:complete
     * @param {object} instance The activated instance.
     * @param {object} instruction The routing instruction.
     * @param {Router} router The router.
     */

    /**
     * Triggered when the navigation has been cancelled.
     * @event router:navigation:cancelled
     * @param {object} instance The activated instance.
     * @param {object} instruction The routing instruction.
     * @param {Router} router The router.
     */

    /**
     * Triggered when navigation begins.
     * @event router:navigation:processing
     * @param {object} instruction The routing instruction.
     * @param {Router} router The router.
     */

    /**
     * Triggered right before a route is activated.
     * @event router:route:activating
     * @param {object} instance The activated instance.
     * @param {object} instruction The routing instruction.
     * @param {Router} router The router.
     */

    /**
     * Triggered right before a route is configured.
     * @event router:route:before-config
     * @param {object} config The route config.
     * @param {Router} router The router.
     */

    /**
     * Triggered just after a route is configured.
     * @event router:route:after-config
     * @param {object} config The route config.
     * @param {Router} router The router.
     */

    /**
     * Triggered when the view for the activated instance is attached.
     * @event router:navigation:attached
     * @param {object} instance The activated instance.
     * @param {object} instruction The routing instruction.
     * @param {Router} router The router.
     */

    /**
     * Triggered when the composition that the activated instance participates in is complete.
     * @event router:navigation:composition-complete
     * @param {object} instance The activated instance.
     * @param {object} instruction The routing instruction.
     * @param {Router} router The router.
     */

    /**
     * Triggered when the router does not find a matching route.
     * @event router:route:not-found
     * @param {string} fragment The url fragment.
     * @param {Router} router The router.
     */

    var createRouter = function() {
        var queue = [],
            isProcessing = ko.observable(false),
            currentActivation,
            currentInstruction,
            activeItem = activator.create();

        var router = {
            /**
             * The route handlers that are registered. Each handler consists of a &#x60;routePattern&#x60; and a &#x60;callback&#x60;.
             * @property {object[]} handlers
             */
            handlers: [],
            /**
             * The route configs that are registered.
             * @property {object[]} routes
             */
            routes: [],
            /**
             * The route configurations that have been designated as displayable in a nav ui (nav:true).
             * @property {KnockoutObservableArray} navigationModel
             */
            navigationModel: ko.observableArray([]),
            /**
             * The active item/screen based on the current navigation state.
             * @property {Activator} activeItem
             */
            activeItem: activeItem,
            /**
             * Indicates that the router (or a child router) is currently in the process of navigating.
             * @property {KnockoutComputed} isNavigating
             */
            isNavigating: ko.computed(function() {
                var current = activeItem();
                var processing = isProcessing();
                var currentRouterIsProcesing = current
                    &amp;&amp; current.router
                    &amp;&amp; current.router != router
                    &amp;&amp; current.router.isNavigating() ? true : false;
                return  processing || currentRouterIsProcesing;
            }),
            /**
             * An observable surfacing the active routing instruction that is currently being processed or has recently finished processing.
             * The instruction object has &#x60;config&#x60;, &#x60;fragment&#x60;, &#x60;queryString&#x60;, &#x60;params&#x60; and &#x60;queryParams&#x60; properties.
             * @property {KnockoutObservable} activeInstruction
             */
            activeInstruction:ko.observable(null),
            __router__:true
        };

        events.includeIn(router);

        activeItem.settings.areSameItem = function (currentItem, newItem, currentActivationData, newActivationData) {
            if (currentItem == newItem) {
                return compareArrays(currentActivationData, newActivationData);
            }

            return false;
        };

        activeItem.settings.findChildActivator = function(item) {
            if (item &amp;&amp; item.router &amp;&amp; item.router.parent == router) {
                return item.router.activeItem;
            }

            return null;
        };

        function hasChildRouter(instance, parentRouter) {
            return instance.router &amp;&amp; instance.router.parent == parentRouter;
        }

        function setCurrentInstructionRouteIsActive(flag) {
            if (currentInstruction &amp;&amp; currentInstruction.config.isActive) {
                currentInstruction.config.isActive(flag);
            }
        }

        function completeNavigation(instance, instruction, mode) {
            system.log(&#x27;Navigation Complete&#x27;, instance, instruction);

            var fromModuleId = system.getModuleId(currentActivation);
            if (fromModuleId) {
                router.trigger(&#x27;router:navigation:from:&#x27; + fromModuleId);
            }

            currentActivation = instance;

            setCurrentInstructionRouteIsActive(false);
            currentInstruction = instruction;
            setCurrentInstructionRouteIsActive(true);

            var toModuleId = system.getModuleId(currentActivation);
            if (toModuleId) {
                router.trigger(&#x27;router:navigation:to:&#x27; + toModuleId);
            }

            if (!hasChildRouter(instance, router)) {
                router.updateDocumentTitle(instance, instruction);
            }

            switch (mode) {
                case &#x27;rootRouter&#x27;:
                    lastUrl = reconstructUrl(currentInstruction);
                    break;
                case &#x27;rootRouterWithChild&#x27;:
                    lastTryUrl = reconstructUrl(currentInstruction);
                    break;
                case &#x27;lastChildRouter&#x27;:
                    lastUrl = lastTryUrl;
                    break;
            }

            rootRouter.explicitNavigation = false;
            rootRouter.navigatingBack = false;

            router.trigger(&#x27;router:navigation:complete&#x27;, instance, instruction, router);
        }

        function cancelNavigation(instance, instruction) {
            system.log(&#x27;Navigation Cancelled&#x27;);

            router.activeInstruction(currentInstruction);

            router.navigate(lastUrl, false);

            isProcessing(false);
            rootRouter.explicitNavigation = false;
            rootRouter.navigatingBack = false;
            router.trigger(&#x27;router:navigation:cancelled&#x27;, instance, instruction, router);
        }

        function redirect(url) {
            system.log(&#x27;Navigation Redirecting&#x27;);

            isProcessing(false);
            rootRouter.explicitNavigation = false;
            rootRouter.navigatingBack = false;
            router.navigate(url, { trigger: true, replace: true });
        }

        function activateRoute(activator, instance, instruction) {
            rootRouter.navigatingBack = !rootRouter.explicitNavigation &amp;&amp; currentActivation != instruction.fragment;
            router.trigger(&#x27;router:route:activating&#x27;, instance, instruction, router);

            var options = {
                canDeactivate: !router.parent
            };

            activator.activateItem(instance, instruction.params, options).then(function(succeeded) {
                if (succeeded) {
                    var previousActivation = currentActivation;
                    var withChild = hasChildRouter(instance, router);
                    var mode = &#x27;&#x27;;

                    if (router.parent) {
                        if(!withChild) {
                            mode = &#x27;lastChildRouter&#x27;;
                        }
                    } else {
                        if (withChild) {
                            mode = &#x27;rootRouterWithChild&#x27;;
                        } else {
                            mode = &#x27;rootRouter&#x27;;
                        }
                    }

                    completeNavigation(instance, instruction, mode);

                    if (withChild) {
                        instance.router.trigger(&#x27;router:route:before-child-routes&#x27;, instance, instruction, router);

                        var fullFragment = instruction.fragment;
                        if (instruction.queryString) {
                            fullFragment += &quot;?&quot; + instruction.queryString;
                        }

                        instance.router.loadUrl(fullFragment);
                    }

                    if (previousActivation == instance) {
                        router.attached();
                        router.compositionComplete();
                    }
                } else if(activator.settings.lifecycleData &amp;&amp; activator.settings.lifecycleData.redirect){
                    redirect(activator.settings.lifecycleData.redirect);
                }else{
                    cancelNavigation(instance, instruction);
                }

                if (startDeferred) {
                    startDeferred.resolve();
                    startDeferred = null;
                }
            }).fail(function(err){
                system.error(err);
            });
        }

        /**
         * Inspects routes and modules before activation. Can be used to protect access by cancelling navigation or redirecting.
         * @method guardRoute
         * @param {object} instance The module instance that is about to be activated by the router.
         * @param {object} instruction The route instruction. The instruction object has config, fragment, queryString, params and queryParams properties.
         * @return {Promise|Boolean|String} If a boolean, determines whether or not the route should activate or be cancelled. If a string, causes a redirect to the specified route. Can also be a promise for either of these value types.
         */
        function handleGuardedRoute(activator, instance, instruction) {
            var resultOrPromise = router.guardRoute(instance, instruction);
            if (resultOrPromise || resultOrPromise === &#x27;&#x27;) {
                if (resultOrPromise.then) {
                    resultOrPromise.then(function(result) {
                        if (result) {
                            if (system.isString(result)) {
                                redirect(result);
                            } else {
                                activateRoute(activator, instance, instruction);
                            }
                        } else {
                            cancelNavigation(instance, instruction);
                        }
                    });
                } else {
                    if (system.isString(resultOrPromise)) {
                        redirect(resultOrPromise);
                    } else {
                        activateRoute(activator, instance, instruction);
                    }
                }
            } else {
                cancelNavigation(instance, instruction);
            }
        }

        function ensureActivation(activator, instance, instruction) {
            if (router.guardRoute) {
                handleGuardedRoute(activator, instance, instruction);
            } else {
                activateRoute(activator, instance, instruction);
            }
        }

        function canReuseCurrentActivation(instruction) {
            return currentInstruction
                &amp;&amp; currentInstruction.config.moduleId == instruction.config.moduleId
                &amp;&amp; currentActivation
                &amp;&amp; ((currentActivation.canReuseForRoute &amp;&amp; currentActivation.canReuseForRoute.apply(currentActivation, instruction.params))
                || (!currentActivation.canReuseForRoute &amp;&amp; currentActivation.router &amp;&amp; currentActivation.router.loadUrl));
        }

        function dequeueInstruction() {
            if (isProcessing()) {
                return;
            }

            var instruction = queue.shift();
            queue = [];

            if (!instruction) {
                return;
            }

            isProcessing(true);
            router.activeInstruction(instruction);
            router.trigger(&#x27;router:navigation:processing&#x27;, instruction, router);

            if (canReuseCurrentActivation(instruction)) {
                var tempActivator = activator.create();
                tempActivator.forceActiveItem(currentActivation); //enforce lifecycle without re-compose
                tempActivator.settings.areSameItem = activeItem.settings.areSameItem;
                tempActivator.settings.findChildActivator = activeItem.settings.findChildActivator;
                ensureActivation(tempActivator, currentActivation, instruction);
            } else if(!instruction.config.moduleId) {
                ensureActivation(activeItem, {
                    viewUrl:instruction.config.viewUrl,
                    canReuseForRoute:function() {
                        return true;
                    }
                }, instruction);
            } else {
                system.acquire(instruction.config.moduleId).then(function(m) {
                    var instance = system.resolveObject(m);

                    if(instruction.config.viewUrl) {
                        instance.viewUrl = instruction.config.viewUrl;
                    }

                    ensureActivation(activeItem, instance, instruction);
                }).fail(function(err) {
                    cancelNavigation(null, instruction);
                    system.error(&#x27;Failed to load routed module (&#x27; + instruction.config.moduleId + &#x27;). Details: &#x27; + err.message, err);
                });
            }
        }

        function queueInstruction(instruction) {
            queue.unshift(instruction);
            dequeueInstruction();
        }

        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as &#x60;null&#x60; to normalize cross-browser behavior.
        function createParams(routePattern, fragment, queryString) {
            var params = routePattern.exec(fragment).slice(1);

            for (var i = 0; i &lt; params.length; i++) {
                var current = params[i];
                params[i] = current ? decodeURIComponent(current) : null;
            }

            var queryParams = router.parseQueryString(queryString);
            if (queryParams) {
                params.push(queryParams);
            }

            return {
                params:params,
                queryParams:queryParams
            };
        }

        function configureRoute(config){
            router.trigger(&#x27;router:route:before-config&#x27;, config, router);

            if (!system.isRegExp(config.route)) {
                config.title = config.title || router.convertRouteToTitle(config.route);

                if (!config.viewUrl) {
                    config.moduleId = config.moduleId || router.convertRouteToModuleId(config.route);
                }

                config.hash = config.hash || router.convertRouteToHash(config.route);

                if (config.hasChildRoutes) {
                    config.route = config.route + &#x27;*childRoutes&#x27;;
                }

                config.routePattern = routeStringToRegExp(config.route);
            }else{
                config.routePattern = config.route;
            }

            config.isActive = config.isActive || ko.observable(false);
            router.trigger(&#x27;router:route:after-config&#x27;, config, router);
            router.routes.push(config);

            router.route(config.routePattern, function(fragment, queryString) {
                var paramInfo = createParams(config.routePattern, fragment, queryString);
                queueInstruction({
                    fragment: fragment,
                    queryString:queryString,
                    config: config,
                    params: paramInfo.params,
                    queryParams:paramInfo.queryParams
                });
            });
        };

        function mapRoute(config) {
            if(system.isArray(config.route)){
                var isActive = config.isActive || ko.observable(false);

                for(var i = 0, length = config.route.length; i &lt; length; i++){
                    var current = system.extend({}, config);

                    current.route = config.route[i];
                    current.isActive = isActive;

                    if(i &gt; 0){
                        delete current.nav;
                    }

                    configureRoute(current);
                }
            }else{
                configureRoute(config);
            }

            return router;
        }

        /**
         * Parses a query string into an object.
         * @method parseQueryString
         * @param {string} queryString The query string to parse.
         * @return {object} An object keyed according to the query string parameters.
         */
        router.parseQueryString = function (queryString) {
            var queryObject, pairs;

            if (!queryString) {
                return null;
            }

            pairs = queryString.split(&#x27;&amp;&#x27;);

            if (pairs.length == 0) {
                return null;
            }

            queryObject = {};

            for (var i = 0; i &lt; pairs.length; i++) {
                var pair = pairs[i];
                if (pair === &#x27;&#x27;) {
                    continue;
                }

                var sp = pair.indexOf(&quot;=&quot;),
                    key = sp === -1 ? pair : pair.substr(0, sp),
                    value = sp === -1 ? null : decodeURIComponent(pair.substr(sp + 1).replace(/\+/g, &#x27; &#x27;));

                var existing = queryObject[key];

                if (existing) {
                    if (system.isArray(existing)) {
                        existing.push(value);
                    } else {
                        queryObject[key] = [existing, value];
                    }
                }
                else {
                    queryObject[key] = value;
                }
            }

            return queryObject;
        };

        /**
         * Add a route to be tested when the url fragment changes.
         * @method route
         * @param {RegEx} routePattern The route pattern to test against.
         * @param {function} callback The callback to execute when the route pattern is matched.
         */
        router.route = function(routePattern, callback) {
            router.handlers.push({ routePattern: routePattern, callback: callback });
        };

        /**
         * Attempt to load the specified URL fragment. If a route succeeds with a match, returns &#x60;true&#x60;. If no defined routes matches the fragment, returns &#x60;false&#x60;.
         * @method loadUrl
         * @param {string} fragment The URL fragment to find a match for.
         * @return {boolean} True if a match was found, false otherwise.
         */
        router.loadUrl = function(fragment) {
            var handlers = router.handlers,
                queryString = null,
                coreFragment = fragment,
                queryIndex = fragment.indexOf(&#x27;?&#x27;);

            if (queryIndex != -1) {
                coreFragment = fragment.substring(0, queryIndex);
                queryString = fragment.substr(queryIndex + 1);
            }

            if(router.relativeToParentRouter){
                var instruction = this.parent.activeInstruction();
				coreFragment = queryIndex == -1 ? instruction.params.join(&#x27;/&#x27;) : instruction.params.slice(0, -1).join(&#x27;/&#x27;);

                if(coreFragment &amp;&amp; coreFragment.charAt(0) == &#x27;/&#x27;){
                    coreFragment = coreFragment.substr(1);
                }

                if(!coreFragment){
                    coreFragment = &#x27;&#x27;;
                }

                coreFragment = coreFragment.replace(&#x27;//&#x27;, &#x27;/&#x27;).replace(&#x27;//&#x27;, &#x27;/&#x27;);
            }

            coreFragment = coreFragment.replace(trailingSlash, &#x27;&#x27;);

            for (var i = 0; i &lt; handlers.length; i++) {
                var current = handlers[i];
                if (current.routePattern.test(coreFragment)) {
                    current.callback(coreFragment, queryString);
                    return true;
                }
            }

            system.log(&#x27;Route Not Found&#x27;, fragment, currentInstruction);
            router.trigger(&#x27;router:route:not-found&#x27;, fragment, router);

            if (router.parent) {
                lastUrl = lastTryUrl;
            }

            history.navigate(lastUrl, { trigger:false, replace:true });

            rootRouter.explicitNavigation = false;
            rootRouter.navigatingBack = false;

            return false;
        };

        var titleSubscription;
        function setTitle(value) {
            var appTitle = ko.unwrap(app.title);

            if (appTitle) {
                document.title = value + &quot; | &quot; + appTitle;
            } else {
                document.title = value;
            }
        }

        // Allow observable to be used for app.title
        if(ko.isObservable(app.title)) {
            app.title.subscribe(function () {
                var instruction = router.activeInstruction();
                var title = instruction != null ? ko.unwrap(instruction.config.title) : &#x27;&#x27;;
                setTitle(title);
            });
        }

        /**
         * Updates the document title based on the activated module instance, the routing instruction and the app.title.
         * @method updateDocumentTitle
         * @param {object} instance The activated module.
         * @param {object} instruction The routing instruction associated with the action. It has a &#x60;config&#x60; property that references the original route mapping config.
         */
        router.updateDocumentTitle = function (instance, instruction) {
            var appTitle = ko.unwrap(app.title),
                title = instruction.config.title;

            if (titleSubscription) {
                titleSubscription.dispose();
            }

            if (title) {
                if (ko.isObservable(title)) {
                    titleSubscription = title.subscribe(setTitle);
                    setTitle(title());
                } else {
                    setTitle(title);
                }
            } else if (appTitle) {
                document.title = appTitle;
            }
        };

        /**
         * Save a fragment into the hash history, or replace the URL state if the
         * &#x27;replace&#x27; option is passed. You are responsible for properly URL-encoding
         * the fragment in advance.
         * The options object can contain &#x60;trigger: false&#x60; if you wish to not have the
         * route callback be fired, or &#x60;replace: true&#x60;, if
         * you wish to modify the current URL without adding an entry to the history.
         * @method navigate
         * @param {string} fragment The url fragment to navigate to.
         * @param {object|boolean} options An options object with optional trigger and replace flags. You can also pass a boolean directly to set the trigger option. Trigger is &#x60;true&#x60; by default.
         * @return {boolean} Returns true/false from loading the url.
         */
        router.navigate = function(fragment, options) {
            if(fragment &amp;&amp; fragment.indexOf(&#x27;://&#x27;) != -1) {
                window.location.href = fragment;
                return true;
            }

            if(options === undefined || (system.isBoolean(options) &amp;&amp; options) || (system.isObject(options) &amp;&amp; options.trigger)) {
                rootRouter.explicitNavigation = true;
            }

            if ((system.isBoolean(options) &amp;&amp; !options) || (options &amp;&amp; options.trigger != undefined &amp;&amp; !options.trigger)) {
                lastUrl = fragment;
            }

            return history.navigate(fragment, options);
        };

        /**
         * Navigates back in the browser history.
         * @method navigateBack
         */
        router.navigateBack = function() {
            history.navigateBack();
        };

        router.attached = function() {
            router.trigger(&#x27;router:navigation:attached&#x27;, currentActivation, currentInstruction, router);
        };

        router.compositionComplete = function(){
            isProcessing(false);
            router.trigger(&#x27;router:navigation:composition-complete&#x27;, currentActivation, currentInstruction, router);
            dequeueInstruction();
        };

        /**
         * Converts a route to a hash suitable for binding to a link&#x27;s href.
         * @method convertRouteToHash
         * @param {string} route
         * @return {string} The hash.
         */
        router.convertRouteToHash = function(route) {
            route = route.replace(/\*.*$/, &#x27;&#x27;);

            if(router.relativeToParentRouter){
                var instruction = router.parent.activeInstruction(),
                    hash = route ? instruction.config.hash + &#x27;/&#x27; + route : instruction.config.hash;

                if(history._hasPushState){
                    hash = &#x27;/&#x27; + hash;
                }

                hash = hash.replace(&#x27;//&#x27;, &#x27;/&#x27;).replace(&#x27;//&#x27;, &#x27;/&#x27;);
                return hash;
            }

            if(history._hasPushState){
                return route;
            }

            return &quot;#&quot; + route;
        };

        /**
         * Converts a route to a module id. This is only called if no module id is supplied as part of the route mapping.
         * @method convertRouteToModuleId
         * @param {string} route
         * @return {string} The module id.
         */
        router.convertRouteToModuleId = function(route) {
            return stripParametersFromRoute(route);
        };

        /**
         * Converts a route to a displayable title. This is only called if no title is specified as part of the route mapping.
         * @method convertRouteToTitle
         * @param {string} route
         * @return {string} The title.
         */
        router.convertRouteToTitle = function(route) {
            var value = stripParametersFromRoute(route);
            return value.substring(0, 1).toUpperCase() + value.substring(1);
        };

        /**
         * Maps route patterns to modules.
         * @method map
         * @param {string|object|object[]} route A route, config or array of configs.
         * @param {object} [config] The config for the specified route.
         * @chainable
         * @example
         router.map([
         { route: &#x27;&#x27;, title:&#x27;Home&#x27;, moduleId: &#x27;homeScreen&#x27;, nav: true },
         { route: &#x27;customer/:id&#x27;, moduleId: &#x27;customerDetails&#x27;}
         ]);
         */
        router.map = function(route, config) {
            if (system.isArray(route)) {
                for (var i = 0; i &lt; route.length; i++) {
                    router.map(route[i]);
                }

                return router;
            }

            if (system.isString(route) || system.isRegExp(route)) {
                if (!config) {
                    config = {};
                } else if (system.isString(config)) {
                    config = { moduleId: config };
                }

                config.route = route;
            } else {
                config = route;
            }

            return mapRoute(config);
        };

        /**
         * Builds an observable array designed to bind a navigation UI to. The model will exist in the &#x60;navigationModel&#x60; property.
         * @method buildNavigationModel
         * @param {number} defaultOrder The default order to use for navigation visible routes that don&#x27;t specify an order. The default is 100 and each successive route will be one more than that.
         * @chainable
         */
        router.buildNavigationModel = function(defaultOrder) {
            var nav = [], routes = router.routes;
            var fallbackOrder = defaultOrder || 100;

            for (var i = 0; i &lt; routes.length; i++) {
                var current = routes[i];

                if (current.nav) {
                    if (!system.isNumber(current.nav)) {
                        current.nav = ++fallbackOrder;
                    }

                    nav.push(current);
                }
            }

            nav.sort(function(a, b) { return a.nav - b.nav; });
            router.navigationModel(nav);

            return router;
        };

        /**
         * Configures how the router will handle unknown routes.
         * @method mapUnknownRoutes
         * @param {string|function} [config] If not supplied, then the router will map routes to modules with the same name.
         * If a string is supplied, it represents the module id to route all unknown routes to.
         * Finally, if config is a function, it will be called back with the route instruction containing the route info. The function can then modify the instruction by adding a moduleId and the router will take over from there.
         * @param {string} [replaceRoute] If config is a module id, then you can optionally provide a route to replace the url with.
         * @chainable
         */
        router.mapUnknownRoutes = function(config, replaceRoute) {
            var catchAllRoute = &quot;*catchall&quot;;
            var catchAllPattern = routeStringToRegExp(catchAllRoute);

            router.route(catchAllPattern, function (fragment, queryString) {
                var paramInfo = createParams(catchAllPattern, fragment, queryString);
                var instruction = {
                    fragment: fragment,
                    queryString: queryString,
                    config: {
                        route: catchAllRoute,
                        routePattern: catchAllPattern
                    },
                    params: paramInfo.params,
                    queryParams: paramInfo.queryParams
                };

                if (!config) {
                    instruction.config.moduleId = fragment;
                } else if (system.isString(config)) {
                    instruction.config.moduleId = config;
                    if(replaceRoute){
                        history.navigate(replaceRoute, { trigger:false, replace:true });
                    }
                } else if (system.isFunction(config)) {
                    var result = config(instruction);
                    if (result &amp;&amp; result.then) {
                        result.then(function() {
                            router.trigger(&#x27;router:route:before-config&#x27;, instruction.config, router);
                            router.trigger(&#x27;router:route:after-config&#x27;, instruction.config, router);
                            queueInstruction(instruction);
                        });
                        return;
                    }
                } else {
                    instruction.config = config;
                    instruction.config.route = catchAllRoute;
                    instruction.config.routePattern = catchAllPattern;
                }

                router.trigger(&#x27;router:route:before-config&#x27;, instruction.config, router);
                router.trigger(&#x27;router:route:after-config&#x27;, instruction.config, router);
                queueInstruction(instruction);
            });

            return router;
        };

        /**
         * Resets the router by removing handlers, routes, event handlers and previously configured options.
         * @method reset
         * @chainable
         */
        router.reset = function() {
            currentInstruction = currentActivation = undefined;
            router.handlers = [];
            router.routes = [];
            router.off();
            delete router.options;
            return router;
        };

        /**
         * Makes all configured routes and/or module ids relative to a certain base url.
         * @method makeRelative
         * @param {string|object} settings If string, the value is used as the base for routes and module ids. If an object, you can specify &#x60;route&#x60; and &#x60;moduleId&#x60; separately. In place of specifying route, you can set &#x60;fromParent:true&#x60; to make routes automatically relative to the parent router&#x27;s active route.
         * @chainable
         */
        router.makeRelative = function(settings){
            if(system.isString(settings)){
                settings = {
                    moduleId:settings,
                    route:settings
                };
            }

            if(settings.moduleId &amp;&amp; !endsWith(settings.moduleId, &#x27;/&#x27;)){
                settings.moduleId += &#x27;/&#x27;;
            }

            if(settings.route &amp;&amp; !endsWith(settings.route, &#x27;/&#x27;)){
                settings.route += &#x27;/&#x27;;
            }

            if(settings.fromParent){
                router.relativeToParentRouter = true;
            }

            router.on(&#x27;router:route:before-config&#x27;).then(function(config){
                if(settings.moduleId){
                    config.moduleId = settings.moduleId + config.moduleId;
                }

                if(settings.route){
                    if(config.route === &#x27;&#x27;){
                        config.route = settings.route.substring(0, settings.route.length - 1);
                    }else{
                        config.route = settings.route + config.route;
                    }
                }
            });

            if (settings.dynamicHash) {
                router.on(&#x27;router:route:after-config&#x27;).then(function (config) {
                    config.routePattern = routeStringToRegExp(config.route ? settings.dynamicHash + &#x27;/&#x27; + config.route : settings.dynamicHash);
                    config.dynamicHash = config.dynamicHash || ko.observable(config.hash);
                });

                router.on(&#x27;router:route:before-child-routes&#x27;).then(function(instance, instruction, parentRouter) {
                    var childRouter = instance.router;

                    for(var i = 0; i &lt; childRouter.routes.length; i++) {
                        var route = childRouter.routes[i];
                        var params = instruction.params.slice(0);

                        route.hash = childRouter.convertRouteToHash(route.route)
                            .replace(namedParam, function(match) {
                                return params.length &gt; 0 ? params.shift() : match;
                            });

                        route.dynamicHash(route.hash);
                    }
                });
            }

            return router;
        };

        /**
         * Creates a child router.
         * @method createChildRouter
         * @return {Router} The child router.
         */
        router.createChildRouter = function() {
            var childRouter = createRouter();
            childRouter.parent = router;
            return childRouter;
        };

        return router;
    };

    /**
     * @class RouterModule
     * @extends Router
     * @static
     */
    rootRouter = createRouter();
    rootRouter.explicitNavigation = false;
    rootRouter.navigatingBack = false;

    /**
     * Makes the RegExp generated for routes case sensitive, rather than the default of case insensitive.
     * @method makeRoutesCaseSensitive
     */
    rootRouter.makeRoutesCaseSensitive = function(){
        routesAreCaseSensitive = true;
    };

    /**
     * Verify that the target is the current window
     * @method targetIsThisWindow
     * @return {boolean} True if the event&#x27;s target is the current window, false otherwise.
     */
    rootRouter.targetIsThisWindow = function(event) {
        var targetWindow = $(event.target).attr(&#x27;target&#x27;);

        if (!targetWindow ||
            targetWindow === window.name ||
            targetWindow === &#x27;_self&#x27; ||
            (targetWindow === &#x27;top&#x27; &amp;&amp; window === window.top)) { return true; }

        return false;
    };

    /**
     * Activates the router and the underlying history tracking mechanism.
     * @method activate
     * @return {Promise} A promise that resolves when the router is ready.
     */
    rootRouter.activate = function(options) {
        return system.defer(function(dfd) {
            startDeferred = dfd;
            rootRouter.options = system.extend({ routeHandler: rootRouter.loadUrl }, rootRouter.options, options);

            history.activate(rootRouter.options);

            if(history._hasPushState){
                var routes = rootRouter.routes,
                    i = routes.length;

                while(i--){
                    var current = routes[i];
                    current.hash = current.hash.replace(&#x27;#&#x27;, &#x27;/&#x27;);
                }
            }

            var rootStripper = rootRouter.options.root &amp;&amp; new RegExp(&quot;^&quot; + rootRouter.options.root + &quot;/&quot;);

            $(document).delegate(&quot;a&quot;, &#x27;click&#x27;, function(evt){
                
                // ignore default prevented since these are not supposed to behave like links anyway
                if(evt.isDefaultPrevented()){
                    return;
                }

                if(history._hasPushState){
                    if(!evt.altKey &amp;&amp; !evt.ctrlKey &amp;&amp; !evt.metaKey &amp;&amp; !evt.shiftKey &amp;&amp; rootRouter.targetIsThisWindow(evt)){
                        var href = $(this).attr(&quot;href&quot;);

                        // Ensure the protocol is not part of URL, meaning its relative.
                        // Stop the event bubbling to ensure the link will not cause a page refresh.
                        if (href != null &amp;&amp; !(href.charAt(0) === &quot;#&quot; || /^[a-z]+:/i.test(href))) {
                            rootRouter.explicitNavigation = true;
                            evt.preventDefault();

                            if (rootStripper) {
                                href = href.replace(rootStripper, &quot;&quot;);
                            }

                            history.navigate(href);
                        }
                    }
                }else{
                    rootRouter.explicitNavigation = true;
                }
            });

            if(history.options.silent &amp;&amp; startDeferred){
                startDeferred.resolve();
                startDeferred = null;
            }
        }).promise();
    };

    /**
     * Deactivate current items and turn history listening off.
     * @method deactivate
     */
    rootRouter.deactivate = function() {
        rootRouter.activeItem(null);
        history.deactivate();
    };

    /**
     * Installs the router&#x27;s custom ko binding handler.
     * @method install
     */
    rootRouter.install = function(){
        ko.bindingHandlers.router = {
            init: function() {
                return { controlsDescendantBindings: true };
            },
            update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var settings = ko.utils.unwrapObservable(valueAccessor()) || {};

                if (settings.__router__) {
                    settings = {
                        model:settings.activeItem(),
                        attached:settings.attached,
                        compositionComplete:settings.compositionComplete,
                        activate: false
                    };
                } else {
                    var theRouter = ko.utils.unwrapObservable(settings.router || viewModel.router) || rootRouter;
                    settings.model = theRouter.activeItem();
                    settings.attached = theRouter.attached;
                    settings.compositionComplete = theRouter.compositionComplete;
                    settings.activate = false;
                }

                composition.compose(element, settings, bindingContext);
            }
        };

        ko.virtualElements.allowedBindings.router = true;
    };

    return rootRouter;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
